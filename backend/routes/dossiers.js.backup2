// ===============================================

const express = require('express');
const router = express.Router();
const multer = require('multer');
const path = require('path');
const fs = require('fs').promises;
const { v4: uuidv4 } = require('uuid');
const db = require('../config/database');
const { authenticateToken: auth } = require('../middleware/auth');
const { isValidId, validateIdParam } = require('../utils/validators');
const { checkDossierPermission, getDossierByIdentifier, logDossierActivity, canAccessDossier } = require('../middleware/permissions');
const socketService = require('../services/socketService');

// Fonction de normalisation des statuts de la base de donn√©es vers les codes frontend
const normalizeStatusForFrontend = (dbStatus) => {
  if (!dbStatus) return 'en_cours'; // valeur par d√©faut
  
  const statusMap = {
    'En cours': 'en_cours',
    '√Ä revoir': 'a_revoir', 
    'En impression': 'en_impression',
    'Termin√©': 'termine',
    'En livraison': 'en_livraison',
    'Livr√©': 'livre',
    // Corriger: "Pr√™t impression" doit rester distinct de "En impression"
    'Pr√™t impression': 'pret_impression', // Mapping correct vers code app
    'Pret impression': 'pret_impression',
    'pret_impression': 'pret_impression',
  };
  
  return statusMap[dbStatus] || dbStatus.toLowerCase().replace(/[^a-z]/g, '_');
};

// Fonction inverse: convertit snake_case -> fran√ßais pour les r√®gles de workflow
const normalizeStatusForWorkflow = (status) => {
  if (!status) return 'En cours';
  
  const workflowMap = {
    'en_cours': 'En cours',
    'a_revoir': '√Ä revoir', 
    'en_impression': 'En impression',
    'termine': 'Termin√©',
    'en_livraison': 'En livraison',
    'livre': 'Livr√©',
    // Corriger: le code "pret_impression" correspond √† "Pr√™t impression"
    'pret_impression': 'Pr√™t impression',
    'pret_livraison': 'Pr√™t livraison',
    'imprime': 'Imprim√©',
  };
  
  return workflowMap[status] || status;
};

// Fonction unifi√©e pour v√©rifier l'acc√®s d'un utilisateur √† un dossier
const checkUserAccess = (dossier, user) => {
  if (!dossier || !user) return { allowed: false, reason: 'Donn√©es manquantes' };
  
  // Admin a acc√®s √† tout
  if (user.role === 'admin') {
    return { allowed: true, reason: 'Admin - acc√®s complet' };
  }
  
  // Pr√©parateur: acc√®s √† ses propres dossiers
  if (user.role === 'preparateur') {
    const isOwner = dossier.created_by === user.id || 
                   dossier.preparateur_id === user.id ||
                   dossier.createdBy === user.id;
    return {
      allowed: isOwner,
      reason: isOwner ? 'Propri√©taire du dossier' : 'Vous n\'√™tes pas le cr√©ateur de ce dossier'
    };
  }
  
  // Imprimeurs: acc√®s selon la machine et le statut
  if (user.role === 'imprimeur_roland' || user.role === 'imprimeur_xerox') {
    const machineType = (dossier.type_formulaire || dossier.machine || dossier.type || '').toLowerCase();
    const requiredMachine = user.role === 'imprimeur_roland' ? 'roland' : 'xerox';
    
    if (!machineType.includes(requiredMachine)) {
      return { 
        allowed: false, 
        reason: `Ce dossier est pour machine ${machineType}, vous g√©rez les ${requiredMachine}` 
      };
    }
    
    // V√©rifier le statut (doit √™tre pr√™t pour impression ou en cours d'impression)
    const status = dossier.statut || dossier.status || '';
    const allowedStatuses = [
      'Pr√™t impression', 'En impression', 'Imprim√©',
      'pret_impression', 'en_impression', 'imprime', 'termine',
      'En cours', 'en_cours' // Parfois les imprimeurs voient les dossiers en cours
    ];
    
    const hasAccess = allowedStatuses.some(s => status.includes(s) || s.includes(status));
    return {
      allowed: hasAccess,
      reason: hasAccess ? 'Dossier accessible pour impression' : `Statut "${status}" non accessible aux imprimeurs`
    };
  }
  
  // Livreur: acc√®s aux dossiers termin√©s et en livraison
  if (user.role === 'livreur') {
    const status = dossier.statut || dossier.status || '';
    const allowedStatuses = [
      'Pr√™t livraison', 'En livraison', 'Livr√©', 'Termin√©',
      'pret_livraison', 'en_livraison', 'livre', 'termine'
    ];
    
    const hasAccess = allowedStatuses.some(s => status.includes(s) || s.includes(status));
    return {
      allowed: hasAccess,
      reason: hasAccess ? 'Dossier accessible pour livraison' : `Statut "${status}" non accessible aux livreurs`
    };
  }
  
  return { allowed: false, reason: `R√¥le "${user.role}" non reconnu` };
};

// Configuration upload Multer avec structure par dossier (utilise folder_id)
const storage = multer.diskStorage({
  destination: async (req, file, cb) => {
    const dossierId = req.params.id || req.body.dossier_id;
    if (!dossierId) {
      return cb(new Error('Dossier ID requis pour upload'));
    }

    // Utiliser folder_id si disponible dans req.dossier (pos√© par checkDossierPermission)
    const folderName = req.dossier?.folder_id || dossierId;
    const uploadPath = path.join(__dirname, '../../uploads/dossiers', folderName);

    try {
      await fs.mkdir(uploadPath, { recursive: true });
      cb(null, uploadPath);
    } catch (error) {
      cb(error);
    }
  },
  filename: (req, file, cb) => {
    const timestamp = Date.now();
    const sanitizedName = file.originalname.replace(/[^a-zA-Z0-9.-]/g, '_');
    cb(null, `${timestamp}_${sanitizedName}`);
  },
});

const upload = multer({
  storage,
  limits: { fileSize: 500 * 1024 * 1024 }, // 500MB max
  fileFilter: (req, file, cb) => {
    const allowedTypes = [
      'application/pdf',
      'image/jpeg',
      'image/jpg',
      'image/png',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      'application/msword',
      'text/plain',
    ];

    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error(`Type de fichier non autoris√©: ${file.mimetype}`));
    }
  },
});

// üîê Middleware de v√©rification des r√¥les
const checkRole = allowedRoles => {
  return (req, res, next) => {
    if (!req.user || !allowedRoles.includes(req.user.role)) {
      return res.status(403).json({
        success: false,
        message: `Acc√®s refus√©. R√¥les autoris√©s: ${allowedRoles.join(', ')}`,
      });
    }
    next();
  };
};

// PUT /dossiers/:id/autoriser-modification - Admin d√©verrouille un dossier valid√©
router.put('/:id/autoriser-modification', auth, checkRole(['admin']), validateIdParam('id'), async (req, res) => {
  try {
    const { id } = req.params;
    // Charger le dossier
    const dossierResult = await db.query('SELECT * FROM dossiers WHERE id = $1', [id]);
    if (dossierResult.rows.length === 0) {
      return res.status(404).json({ success: false, message: 'Ce dossier n\'existe pas ou vous n\'avez pas l\'autorisation pour cette action' });
    }
    const dossier = dossierResult.rows[0];
    // V√©rifier qu'il est bien valid√© (colonne sans accent)
    if (!dossier.valide_preparateur) {
      return res.status(400).json({
        success: false,
        message: "Le dossier n'est pas valid√©, aucune action n√©cessaire.",
      });
    }
    // D√©verrouiller le dossier et remettre le statut √† "en_cours"
    const updateQuery = `
      UPDATE dossiers SET valide_preparateur = false, statut = 'en_cours', date_validation_preparateur = NULL WHERE id = $1 RETURNING *
    `;
    const result = await db.query(updateQuery, [id]);
    const updated = result.rows[0];
    // Socket.IO (optionnel)
    const io = req.app.get('io');
    if (io) {
      io.emit('dossier_unlocked', {
        dossier: updated,
        unlocked_by: req.user.nom,
        message: `Dossier ${updated.numero_commande || updated.numero} d√©verrouill√© par admin`,
      });
    }
    return res.json({
      success: true,
      message: 'Dossier d√©verrouill√©, le pr√©parateur peut √† nouveau le modifier.',
      dossier: updated,
    });
  } catch (error) {
    console.error('Erreur autoriser modification:', error);
    return res.status(500).json({
      success: false,
      message: 'Erreur lors du d√©verrouillage du dossier',
      error: error.message,
    });
  }
});

// üìä Filtrage des dossiers selon le r√¥le utilisateur - Version robuste (compat sch√©mas)
const filterDossiersByRole = (user, baseQuery = '', paramOffset = 0) => {
  // Helper: expression SQL pour type/machine normalis√©e
  const machineExpr = 'LOWER(COALESCE(d.type_formulaire, d.machine))';
  switch (user.role) {
    case 'preparateur': {
      const idx = paramOffset + 1;
      // Pr√©parateur: voit tous ses dossiers (quel que soit le statut)
      const condition = `(d.preparateur_id = $${idx} OR d.created_by = $${idx})`;
      return baseQuery.toUpperCase().includes('WHERE')
        ? `${baseQuery} AND (${condition})`
        : `${baseQuery} WHERE ${condition}`;
    }
    case 'imprimeur_roland': {
      // Imprimeur Roland: voit dossiers Roland aux statuts de production
      const condition = `${machineExpr} LIKE 'roland%' AND d.statut IN ('Pr√™t impression','En impression','Imprim√©','pret_impression','en_impression','imprime','termine')`;
      return baseQuery.toUpperCase().includes('WHERE')
        ? `${baseQuery} AND (${condition})`
        : `${baseQuery} WHERE ${condition}`;
    }
    case 'imprimeur_xerox': {
      const condition = `${machineExpr} LIKE 'xerox%' AND d.statut IN ('Pr√™t impression','En impression','Imprim√©','pret_impression','en_impression','imprime','termine')`;
      return baseQuery.toUpperCase().includes('WHERE')
        ? `${baseQuery} AND (${condition})`
        : `${baseQuery} WHERE ${condition}`;
    }
    case 'livreur': {
      const condition = `d.statut IN ('Pr√™t livraison','En livraison','Livr√©','Termin√©','pret_livraison','en_livraison','livre','termine')`;
      return baseQuery.toUpperCase().includes('WHERE')
        ? `${baseQuery} AND (${condition})`
        : `${baseQuery} WHERE ${condition}`;
    }
    case 'admin':
      return baseQuery;
    default:
      return baseQuery.toUpperCase().includes('WHERE')
        ? `${baseQuery} AND 1=0`
        : `${baseQuery} WHERE 1=0`;
  }
};

// üéØ G√©n√©ration automatique du num√©ro de commande
const generateNumeroCommande = async () => {
  const year = new Date().getFullYear();
  try {
    const result = await db.query("SELECT nextval('numero_commande_seq') as next_num");
    const num = result.rows?.[0]?.next_num ?? Math.floor(Math.random() * 10000);
    return `CMD-${year}-${String(num).padStart(4, '0')}`;
  } catch (e) {
    // Fallback if sequence doesn't exist: timestamp-based unique number
    const ts = Date.now().toString().slice(-6);
    return `CMD-${year}-${ts}`;
  }
};

// ==========================================
// üìÇ ROUTES PRINCIPALES
// ==========================================

// üìã GET /dossiers - Liste des dossiers (filtr√©e par r√¥le)
router.get('/', auth, async (req, res) => {
  try {
    // Accept both backend-native params and frontend aliases
    const {
      page = 1,
      limit = 50,
      statut: statutParam,
      machine: machineRaw,
      type: typeRaw,
      search,
    } = req.query;

    // Map app status codes to backend French labels if needed
    const statutMap = {
      en_cours: 'en_cours',
      a_revoir: 'a_revoir',
      en_impression: 'en_impression',
      termine: 'termine',
      en_livraison: 'en_livraison',
      livre: 'livre',
    };

    const statut = statutParam || undefined;
    const machine =
      machineRaw ||
      (typeRaw
        ? String(typeRaw).toLowerCase().startsWith('roland')
          ? 'Roland'
          : String(typeRaw).toLowerCase().startsWith('xerox')
            ? 'Xerox'
            : typeRaw
        : undefined);
    const offset = (page - 1) * limit;

    let baseQuery = `
      SELECT d.*, d."valid√©_preparateur" as valide_preparateur, u.nom as preparateur_name, u.email as preparateur_email,
        (SELECT COUNT(*) FROM fichiers WHERE dossier_id = d.id) as nb_fichiers
      FROM dossiers d
      LEFT JOIN users u ON d.preparateur_id = u.id
    `;

    const conditions = [];
    const params = [];
    let paramIndex = 1;

    // N'appliquer un filtre statut que si ce n'est pas un imprimeur (les r√¥les imprimeurs imposent d√©j√† leurs statuts)
    if (statut && !['imprimeur_roland', 'imprimeur_xerox'].includes(req.user.role)) {
      conditions.push(`d.statut = $${paramIndex++}`);
      params.push(statut);
    }

    // Filtrer par machine de mani√®re robuste (type_formulaire OU machine)
    if (machine) {
      conditions.push(`LOWER(COALESCE(d.type_formulaire, d.machine)) LIKE $${paramIndex++}`);
      const m = String(machine).toLowerCase();
      params.push(m.startsWith('roland') ? 'roland%' : m.startsWith('xerox') ? 'xerox%' : `%${m}%`);
    }

    if (search) {
      conditions.push(
        `(d.client ILIKE $${paramIndex++} OR d.numero_commande ILIKE $${paramIndex++} OR d.description ILIKE $${paramIndex++})`
      );
      params.push(`%${search}%`, `%${search}%`, `%${search}%`);
    }

    // Ajout des conditions de r√¥le AVANT la construction finale de la requ√™te
    const listParams = [...params];

    // Ajouter les conditions de r√¥le selon le type d'utilisateur
    switch (req.user.role) {
      case 'preparateur':
        conditions.push(`(d.preparateur_id = $${paramIndex++} OR d.created_by = $${paramIndex++})`);
        listParams.push(req.user.id, req.user.id);
        break;
      case 'imprimeur_roland':
        conditions.push(
          `LOWER(COALESCE(d.type_formulaire, d.machine)) LIKE 'roland%' AND d.statut IN ('Pr√™t impression','En impression','Imprim√©','pret_impression','en_impression','imprime','termine')`
        );
        break;
      case 'imprimeur_xerox':
        conditions.push(
          `LOWER(COALESCE(d.type_formulaire, d.machine)) LIKE 'xerox%' AND d.statut IN ('Pr√™t impression','En impression','Imprim√©','pret_impression','en_impression','imprime','termine')`
        );
        break;
      case 'livreur':
        conditions.push(
          `d.statut IN ('Pr√™t livraison','En livraison','Livr√©','Termin√©','pret_livraison','en_livraison','livre','termine')`
        );
        break;
      case 'admin':
        // Admin voit tout, pas de condition
        break;
      default:
        conditions.push('1=0'); // Aucun acc√®s
        break;
    }

    // Construction de la clause WHERE finale
    if (conditions.length > 0) {
      baseQuery += ` WHERE ${conditions.join(' AND ')}`;
    }

    const finalQuery = `
      ${baseQuery}
      ORDER BY d.created_at DESC
      LIMIT $${listParams.length + 1} OFFSET $${listParams.length + 2}
    `;

    // Debug: afficher la requ√™te et les param√®tres
    console.log(`üîç DEBUG - R√¥le: ${req.user.role}, ID: ${req.user.id}`);
    console.log(`üîç DEBUG - Requ√™te SQL: ${finalQuery}`);
    console.log(`üîç DEBUG - Param√®tres: ${JSON.stringify([...listParams, limit, offset])}`);

    // V√©rification requ√™te SQL
    let sqlError = null;
    if (!finalQuery || !finalQuery.trim().toLowerCase().startsWith('select')) {
      sqlError = 'Requ√™te SQL non g√©n√©r√©e ou mal form√©e.';
    }
    // V√©rifier le nombre de param√®tres ($) dans la requ√™te
    const paramCount = (finalQuery.match(/\$[0-9]+/g) || []).length;
    const providedCount = [...listParams, limit, offset].length;
    if (paramCount !== providedCount) {
      sqlError = `Nombre de param√®tres attendu (${paramCount}) diff√©rent du nombre fourni (${providedCount}).`;
    }
    // V√©rifier qu'il n'y a pas deux WHERE cons√©cutifs
    if (/where\s+where/i.test(finalQuery)) {
      sqlError = 'Erreur de syntaxe SQL : double WHERE.';
    }
    if (sqlError) {
      console.error('‚ùå Erreur requ√™te SQL:', sqlError);
      return res.status(500).json({
        success: false,
        message: 'Erreur interne: requ√™te SQL incorrecte',
        error: sqlError,
        debug: { query: finalQuery, params: [...listParams, limit, offset] },
      });
    }

    const result = await db.query(finalQuery, [...listParams, limit, offset]);

    // Ajout du champ type normalis√© et statut normalis√© pour chaque dossier
    const dossiers = result.rows.map(d => ({
      ...d,
      type: d.type_formulaire || d.machine || null,
      statut: normalizeStatusForFrontend(d.statut), // Normaliser le statut
    }));

    // Requ√™te de count avec les m√™mes conditions que la requ√™te principale
    let countQuery = `SELECT COUNT(*) FROM dossiers d`;
    const countParams = [...listParams];
    if (conditions.length > 0) {
      countQuery += ` WHERE ${conditions.join(' AND ')}`;
    }
    const countResult = await db.query(countQuery, countParams);
    const total = parseInt(countResult.rows[0].count, 10);
    const pages = Math.ceil(total / limit);
    res.json({
      success: true,
      dossiers,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages,
        // Champs additionnels pour compatibilit√© frontend
        total_pages: pages,
        total_items: total,
      },
      user_role: req.user.role,
    });
  } catch (error) {
    console.error('Erreur GET /dossiers:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la r√©cup√©ration des dossiers',
      error: error.message,
    });
  }
});

// üìÑ GET /dossiers/:id - D√©tail d'un dossier (supporte folder_id UUID)
router.get('/:id', auth, checkDossierPermission('view'), async (req, res) => {
  try {
    const { id } = req.params;

    // Le dossier a d√©j√† √©t√© charg√© et v√©rifi√© par le middleware checkDossierPermission
    const dossier = req.dossier;

    // Essayer de r√©cup√©rer un formulaire structur√© si pr√©sent
    let formDetails = null;
    try {
      const fr = await db.query(
        `SELECT type_formulaire, details, date_saisie FROM dossier_formulaires WHERE dossier_id = $1 ORDER BY date_saisie DESC LIMIT 1`,
        [dossier.id]
      );
      if (fr.rows.length > 0) formDetails = fr.rows[0];
    } catch (e) {
      // table possiblement absente, ignorer
    }
    // Fallback: si aucun formulaire structur√© en base, tenter de d√©duire un minimum
    if (!formDetails) {
      const machine = dossier.machine;
      const desc = dossier.description || '';
      const qty = dossier.quantite || null;
      const commentaires = dossier.commentaires || dossier.commentaire || '';
      let inferred = null;
      if ((machine || '').toLowerCase().includes('xerox')) {
        inferred = {};
        if (desc) inferred.format = desc;
        if (qty) inferred.nombre_exemplaires = qty;
      } else if ((machine || '').toLowerCase().includes('roland')) {
        inferred = {};
        if (desc) inferred.dimension = desc;
      }
      // Essayer d'extraire quelques paires cl√©:valeur depuis commentaires
      try {
        const txt = String(commentaires || '');
        if (txt) {
          const addKV = (key, val) => {
            if (val && !inferred[key]) inferred[key] = val;
          };
          for (const rawLine of txt.split('\n')) {
            const line = rawLine.trim();
            if (!line) continue;
            const [k, ...rest] = line.split(':');
            if (!k || rest.length === 0) continue;
            const v = rest.join(':').trim();
            const kl = k
              .normalize('NFD')
              .replace(/[\u0300-\u036f]/g, '')
              .toLowerCase();
            if (kl.startsWith('format')) addKV('format', v);
            if (kl.startsWith('dimension')) addKV('dimension', v);
            if (kl.startsWith('exemplaire')) addKV('nombre_exemplaires', v);
            if (kl.includes('type') && kl.includes('document') && !kl.includes('autre'))
              addKV('type_document', v);
            if (kl.includes('type') && kl.includes('document') && kl.includes('autre'))
              addKV('type_document_autre', v);
            if (kl.includes('papier') && !kl.includes('autre')) addKV('type_papier', v);
            if (kl.includes('papier') && kl.includes('autre')) addKV('type_papier_autre', v);
          }
        }
      } catch (_) {}
      if (inferred && Object.keys(inferred).length > 0) {
        formDetails = { type_formulaire: machine, details: inferred, date_saisie: new Date() };
      }
    }

    const filesQuery = `
      SELECT f.*, u.nom as uploaded_by_name 
      FROM fichiers f
      LEFT JOIN users u ON f.uploaded_by = u.id
      WHERE f.dossier_id = $1
      ORDER BY f.uploaded_at DESC
    `;

    const filesResult = await db.query(filesQuery, [dossier.id]);

    const historyQuery = `
      SELECT h.*, u.nom as changed_by_name
      FROM dossier_status_history h
      LEFT JOIN users u ON h.changed_by = u.id
      WHERE h.dossier_id = $1
      ORDER BY h.changed_at DESC
    `;

    const historyResult = await db.query(historyQuery, [dossier.id]);

    res.json({
      success: true,
      dossier: {
        ...dossier,
        id: dossier.folder_id, // Utiliser folder_id comme ID principal pour le frontend
        legacy_id: dossier.id, // Garder l'ID integer pour r√©f√©rence
        statut: normalizeStatusForFrontend(dossier.statut), // Normaliser le statut pour le frontend
        ...(formDetails
          ? { data_formulaire: formDetails.details, type_formulaire: formDetails.type_formulaire }
          : {}),
        fichiers: filesResult.rows,
        historique: historyResult.rows,
      },
    });
  } catch (error) {
    console.error('Erreur GET /dossiers/:id:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la r√©cup√©ration du dossier',
      error: error.message,
    });
  }
});

// üÜï POST /dossiers - Cr√©er un nouveau dossier (Pr√©parateur et Admin)
// Nouvelle route POST /dossiers avec gestion UUID et structure conforme au cahier des charges
router.post('/', auth, checkRole(['preparateur', 'admin']), async (req, res) => {
  try {
    const {
      client,
      type_formulaire,
      data_formulaire = {},
      commentaire = '',
      quantite = 1,
      date_livraison = null,
      mode_paiement = null,
      montant_cfa = null,
    } = req.body;

    if (!client || !type_formulaire) {
      return res.status(400).json({
        success: false,
        message: 'Client et type_formulaire sont obligatoires',
      });
    }

    if (!['roland', 'xerox'].includes(type_formulaire.toLowerCase())) {
      return res.status(400).json({
        success: false,
        message: 'type_formulaire doit √™tre roland ou xerox',
      });
    }

    // G√©n√©ration du num√©ro unique
    const numero = await generateNumeroCommande();

    // Cr√©ation du dossier avec preparateur_id et folder_id UUID
    const folderId = uuidv4(); // G√©n√©rer UUID pour folder_id
    const dossierQuery = `
      INSERT INTO dossiers (
        folder_id, numero, client, type_formulaire, statut, preparateur_id, data_formulaire, commentaire, quantite, date_livraison, mode_paiement, montant_cfa
      ) VALUES ($1, $2, $3, $4, 'en_cours', $5, $6, $7, $8, $9, $10, $11)
      RETURNING *
    `;
    const values = [
      folderId,
      numero,
      client,
      type_formulaire,
      req.user.id,
      data_formulaire,
      commentaire,
      quantite,
      date_livraison,
      mode_paiement,
      montant_cfa,
    ];
    const result = await db.query(dossierQuery, values);
    const dossier = result.rows[0];

    // Ajout : sauvegarde structur√©e du formulaire
    try {
      await db.query(
        `INSERT INTO dossier_formulaires (dossier_id, type_formulaire, details) VALUES ($1, $2, $3)`,
        [dossier.id, type_formulaire, data_formulaire]
      );
    } catch (e) {
      console.warn("‚ö†Ô∏è Impossible d'ins√©rer dans dossier_formulaires:", e.message);
    }

    // Cr√©ation du dossier sur le disque
    const uploadPath = path.join(__dirname, '../../uploads', String(dossier.id));
    await fs.mkdir(uploadPath, { recursive: true });

    // Synchronisation Socket.IO via le service centralis√©
    socketService.emitDossierCreated(dossier);
    
    // Logger l'activit√©
    await logDossierActivity(dossier.folder_id, req.user.id, 'created', {
      numero,
      client,
      type_formulaire,
    });

    res.status(201).json({
      success: true,
      message: `Dossier ${numero} cr√©√© avec succ√®s`,
      dossier: {
        ...dossier,
        id: dossier.folder_id, // Retourner folder_id comme ID principal
        legacy_id: dossier.id,
      },
    });
  } catch (error) {
    console.error('Erreur POST /dossiers:', error);
    return res.status(500).json({
      success: false,
      message: 'Erreur lors de la cr√©ation du dossier',
      error: error.message,
    });
  }
});

// ‚úèÔ∏è PUT /dossiers/:id - Modifier un dossier (supporte folder_id UUID)
router.put('/:id', auth, checkDossierPermission('update'), async (req, res) => {
  try {
    const { id } = req.params;
    const {
      client,
      machine,
      description,
      quantite,
      client_email,
      client_telephone,
      date_livraison_prevue,
    } = req.body;
    // Compat: accepter `commentaire` (singulier) et mapper vers `commentaires` si n√©cessaire
    const commentaires =
      req.body?.commentaires !== undefined
        ? req.body.commentaires
        : req.body?.commentaire !== undefined
          ? req.body.commentaire
          : undefined;

    // Le dossier a d√©j√† √©t√© charg√© et v√©rifi√© par checkDossierPermission
    const dossier = req.dossier;
    const oldData = { ...dossier }; // Pour tracker les changements

    const canModify =
      req.user.role === 'admin' ||
      (req.user.role === 'preparateur' &&
        dossier.created_by === parseInt(parseInt(req.user.id)) &&
        !dossier.valide_preparateur) ||
      (req.user.role === 'preparateur' && dossier.statut === '√Ä revoir');

    if (!canModify) {
      return res.status(403).json({
        success: false,
        message:
          "Modification non autoris√©e. Le dossier est valid√© ou vous n'en √™tes pas le cr√©ateur.",
      });
    }

    const updates = [];
    const values = [];
    let paramIndex = 1;

    if (client !== undefined) {
      updates.push(`client = $${paramIndex++}`);
      values.push(client);
    }

    if (machine !== undefined && ['Roland', 'Xerox'].includes(machine)) {
      updates.push(`machine = $${paramIndex++}`);
      values.push(machine);
    }

    if (description !== undefined) {
      updates.push(`description = $${paramIndex++}`);
      values.push(description);
    }

    if (quantite !== undefined) {
      updates.push(`quantite = $${paramIndex++}`);
      values.push(parseInt(quantite));
    }

    if (client_email !== undefined) {
      updates.push(`client_email = $${paramIndex++}`);
      values.push(client_email);
    }

    if (client_telephone !== undefined) {
      updates.push(`client_telephone = $${paramIndex++}`);
      values.push(client_telephone);
    }

    if (date_livraison_prevue !== undefined) {
      updates.push(`date_livraison_prevue = $${paramIndex++}`);
      values.push(date_livraison_prevue);
    }

    if (commentaires !== undefined) {
      updates.push(`commentaires = $${paramIndex++}`);
      values.push(commentaires);
    }

    if (updates.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Aucune donn√©e √† modifier',
      });
    }

    values.push(id);

    const updateQuery = `
      UPDATE dossiers 
      SET ${updates.join(', ')} 
      WHERE id = $${paramIndex}
      RETURNING *
    `;

    const result = await db.query(updateQuery, values);
    const updatedDossier = result.rows[0];

    // Enregistrer un snapshot des d√©tails si form_data/type_formulaire fournis
    try {
      const body = req.body || {};
      let formData = body.form_data || body.data_formulaire || null;
      const tfRaw = body.type_formulaire || body.machine || updatedDossier?.machine || null;
      // Fallback: si formData non fourni mais certains champs ont chang√©, tenter de d√©duire minimal
      if (!formData) {
        const desc = (description !== undefined ? description : updatedDossier?.description) || '';
        const qtyVal = (quantite !== undefined ? quantite : updatedDossier?.quantite) || null;
        if (
          String(tfRaw || '')
            .toLowerCase()
            .includes('xerox')
        ) {
          const inferred = {};
          if (desc) inferred.format = desc;
          if (qtyVal) inferred.nombre_exemplaires = parseInt(qtyVal);
          if (Object.keys(inferred).length > 0) formData = inferred;
        } else if (
          String(tfRaw || '')
            .toLowerCase()
            .includes('roland')
        ) {
          const inferred = {};
          if (desc) inferred.dimension = desc;
          if (Object.keys(inferred).length > 0) formData = inferred;
        }
      }
      if (formData && typeof formData === 'object' && tfRaw) {
        const tf = tfRaw.toString().toLowerCase().includes('roland')
          ? 'Roland'
          : tfRaw.toString().toLowerCase().includes('xerox')
            ? 'Xerox'
            : null;
        if (tf) {
          await db.query(
            `INSERT INTO dossier_formulaires (dossier_id, type_formulaire, details) VALUES ($1, $2, $3)`,
            [id, tf, formData]
          );
        }
      }
    } catch (e) {
      console.warn("‚ö†Ô∏è Impossible d'enregistrer form_data lors du PUT:", e.message);
    }

    // √âmission Socket.IO avec le service centralis√©
    const changes = {};
    if (client !== undefined) changes.client = { old: oldData.client, new: client };
    if (machine !== undefined) changes.machine = { old: oldData.machine, new: machine };
    if (description !== undefined) changes.description = { old: oldData.description, new: description };
    socketService.emitDossierUpdated(updatedDossier, changes);
    
    // Logger l'activit√©
    await logDossierActivity(updatedDossier.folder_id, req.user.id, 'updated', changes);

    res.json({
      success: true,
      message: 'Dossier modifi√© avec succ√®s',
      dossier: {
        ...updatedDossier,
        id: updatedDossier.folder_id,
        legacy_id: updatedDossier.id,
      },
    });
  } catch (error) {
    console.error('Erreur PUT /dossiers/:id:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la modification du dossier',
      error: error.message,
    });
  }
});

// Factoriser le changement de statut pour r√©utilisation
async function changeStatutCore(req, res) {
  try {
    const { id } = req.params;
    const { nouveau_statut, commentaire = null } = req.body;
    // Champs optionnels pour la livraison/paiement
    const date_livraison_prevue = req.body?.date_livraison_prevue ?? undefined;
    const date_livraison = req.body?.date_livraison ?? undefined;
    const mode_paiement = req.body?.mode_paiement ?? undefined;
    // accepter montant_paye (frontend) et mapper vers montant_cfa
    const montant_cfa =
      req.body?.montant_cfa !== undefined
        ? req.body.montant_cfa
        : req.body?.montant_paye !== undefined
          ? req.body.montant_paye
          : undefined;

    // √âtats √©tendus selon le cahier des charges
    const statusAllowed = [
      'Nouveau',
      'En pr√©paration', // alias de "En cours" si n√©cessaire
      'En cours',
      '√Ä revoir',
      'Pr√™t impression',
      'En impression',
      'Imprim√©',
      'Pr√™t livraison',
      'En livraison',
      'Livr√©',
      'Termin√©',
    ];

    if (!statusAllowed.includes(nouveau_statut)) {
      return res.status(400).json({
        success: false,
        message: `Statut invalide. Autoris√©s: ${statusAllowed.join(', ')}`,
      });
    }

    const checkQuery = filterDossiersByRole(
      req.user,
      `
      SELECT d.* FROM dossiers d WHERE d.id = $1
    `,
      1
    );

    const checkParams = [id];
    if (req.user.role === 'preparateur') {
      checkParams.push(parseInt(req.user.id));
    }

    const checkResult = await db.query(checkQuery, checkParams);

    if (checkResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Ce dossier n\'existe pas ou vous n\'avez pas l\'autorisation pour cette action',
      });
    }

    const dossier = checkResult.rows[0];

    // R√®gle: "√Ä revoir" n√©cessite un commentaire
    if (nouveau_statut === '√Ä revoir' && (!commentaire || !String(commentaire).trim())) {
      return res.status(400).json({
        success: false,
        message: 'Un commentaire est requis pour passer un dossier en "√Ä revoir"',
        code: 'COMMENT_REQUIRED',
      });
    }

    const canChangeStatus = () => {
      // Normaliser les statuts pour la comparaison
      const current = normalizeStatusForWorkflow(dossier.statut);
      const target = normalizeStatusForWorkflow(nouveau_statut);
      
      switch (req.user.role) {
        case 'admin': {
          // Admin: toutes transitions raisonn√©es
          const adminTransitions = {
            '√Ä revoir': ['En cours'],
            'En cours': ['√Ä revoir', 'Pr√™t impression', 'En impression'], // compat legacy
            'Pr√™t impression': ['En impression', '√Ä revoir'],
            'En impression': ['Imprim√©', '√Ä revoir', 'En cours'],
            'Imprim√©': ['Pr√™t livraison', 'En impression', '√Ä revoir'],
            'Pr√™t livraison': ['En livraison', 'Imprim√©'],
            'En livraison': ['Livr√©', 'Pr√™t livraison'],
            'Livr√©': ['Termin√©', 'Pr√™t livraison'],
            'Termin√©': [],
          };
          return (adminTransitions[current] || []).includes(target);
        }
        case 'preparateur':
          // Le pr√©parateur corrige depuis "√Ä revoir" ‚Üí "En cours"
          return (
            dossier.created_by === parseInt(req.user.id) &&
            current === '√Ä revoir' &&
            target === 'En cours'
          );
        case 'imprimeur_roland':
        case 'imprimeur_xerox': {
          // Imprimeur: pr√©pare ou imprime
          const printTransitions = {
            'En cours': ['√Ä revoir', 'En impression'], // compat legacy
            'Pr√™t impression': ['En impression', '√Ä revoir'],
            'En impression': ['Imprim√©', '√Ä revoir', 'Pr√™t livraison'],
            'Imprim√©': ['Pr√™t livraison', '√Ä revoir'],
          };
          return (printTransitions[current] || []).includes(target);
        }
        case 'livreur': {
          // Livreur: de pr√™t √† en livraison puis Termin√© (final)
          if (current === 'Pr√™t livraison' && target === 'En livraison') return true;
          if (
            current === 'En livraison' &&
            (target === 'Termin√©' || target === 'Livr√©')
          )
            return true; // accepter 'Livr√©' en alias
          return false;
        }
        default:
          return false;
      }
    };

    if (!canChangeStatus()) {
      return res.status(403).json({
        success: false,
        message: `Changement de statut non autoris√©. Statut actuel: ${dossier.statut}, Votre r√¥le: ${req.user.role}`,
      });
    }

    // Construire dynamiquement la mise √† jour pour persister les champs de livraison/paiement
    const setClauses = ['statut = $1', 'commentaire_revision = $2'];
    const extraValues = [];
    let paramIndex = 4; // $3 est r√©serv√© pour l'ID dans le WHERE

    // Pour la planification de livraison
    if (nouveau_statut === 'En livraison' && date_livraison_prevue !== undefined) {
      setClauses.push(`date_livraison_prevue = $${paramIndex++}`);
      extraValues.push(date_livraison_prevue);
    }
    // Pour la confirmation de livraison (finaliser en "Termin√©")
    if (nouveau_statut === 'Livr√©' || nouveau_statut === 'Termin√©') {
      // Si une date est fournie, l'utiliser, sinon par d√©faut NOW()
      if (date_livraison !== undefined && String(date_livraison).trim() !== '') {
        setClauses.push(`date_livraison = $${paramIndex++}`);
        extraValues.push(date_livraison);
      } else {
        setClauses.push(`date_livraison = NOW()`);
      }
      if (mode_paiement !== undefined) {
        setClauses.push(`mode_paiement = $${paramIndex++}`);
        extraValues.push(mode_paiement);
      }
      if (montant_cfa !== undefined && montant_cfa !== null && montant_cfa !== '') {
        setClauses.push(`montant_cfa = $${paramIndex++}`);
        extraValues.push(parseFloat(montant_cfa));
      }
    }

    // Si on a re√ßu 'Livr√©', on persiste en 'Termin√©'
    const statutToPersist = nouveau_statut === 'Livr√©' ? 'Termin√©' : nouveau_statut;

    const updateQuery = `
      UPDATE dossiers 
      SET ${setClauses.join(', ')}
      WHERE id = $3
      RETURNING *
    `;

    const result = await db.query(updateQuery, [statutToPersist, commentaire, id, ...extraValues]);
    const updatedDossier = result.rows[0];

    if (commentaire) {
      await db.query(
        `
        UPDATE dossier_status_history 
        SET commentaire = $1 
        WHERE id = (
          SELECT id FROM dossier_status_history 
          WHERE dossier_id = $2 AND nouveau_statut = $3 AND commentaire IS NULL
          ORDER BY changed_at DESC LIMIT 1
        )
      `,
        [commentaire, id, nouveau_statut]
      );
    }

    // √âmission Socket.IO via service centralis√©
    socketService.emitStatusChanged(
      updatedDossier.folder_id, 
      dossier.statut, 
      statutToPersist, 
      updatedDossier
    );
    
    // Logger l'activit√©
    await logDossierActivity(updatedDossier.folder_id, req.user.id, 'status_changed', {
      old_status: dossier.statut,
      new_status: statutToPersist,
      commentaire,
    });

    return res.json({
      success: true,
      message: `Statut chang√©: ${dossier.statut} ‚Üí ${nouveau_statut}`,
      dossier: {
        ...updatedDossier,
        id: updatedDossier.folder_id,
        legacy_id: updatedDossier.id,
      },
    });
  } catch (error) {
    console.error('Erreur changement de statut:', error);
    return res.status(500).json({
      success: false,
      message: 'Erreur lors du changement de statut',
      error: error.message,
    });
  }
}

// Fonction de changement de statut utilisant le dossier d√©j√† charg√© par le middleware
async function changeStatutCoreFixed(req, res) {
  try {
    // Log debug
    console.log('[CHANGE_STATUS] user:', { id: req.user?.id, role: req.user?.role }, 'param:', req.params?.id, 'hasDossier:', !!req.dossier);

    // Le dossier a d√©j√† √©t√© charg√© par checkDossierPermission et est dans req.dossier
    const dossier = req.dossier;
    const { nouveau_statut, commentaire = null } = req.body;
    
    // Champs optionnels pour la livraison/paiement
    const date_livraison_prevue = req.body?.date_livraison_prevue ?? undefined;
    const date_livraison = req.body?.date_livraison ?? undefined;
    const mode_paiement = req.body?.mode_paiement ?? undefined;
    const montant_cfa =
      req.body?.montant_cfa !== undefined
        ? req.body.montant_cfa
        : req.body?.montant_paye !== undefined
          ? req.body.montant_paye
          : undefined;

    // √âtats √©tendus selon le cahier des charges
    const statusAllowed = [
      'Nouveau',
      'En pr√©paration',
      'En cours',
      '√Ä revoir',
      'Pr√™t impression',
      'En impression',
      'Imprim√©',
      'Pr√™t livraison',
      'En livraison',
      'Livr√©',
      'Termin√©',
    ];

    if (!statusAllowed.includes(nouveau_statut)) {
      return res.status(400).json({
        success: false,
        message: `Statut invalide. Autoris√©s: ${statusAllowed.join(', ')}`,
      });
    }

    // R√®gle: "√Ä revoir" n√©cessite un commentaire
    if (nouveau_statut === '√Ä revoir' && (!commentaire || !String(commentaire).trim())) {
      return res.status(400).json({
        success: false,
        message: 'Un commentaire est requis pour passer un dossier en "√Ä revoir"',
        code: 'COMMENT_REQUIRED',
      });
    }

    // Validation des transitions selon les r√¥les
    const canChangeStatus = () => {
      const current = normalizeStatusForWorkflow(dossier.statut);
      const target = normalizeStatusForWorkflow(nouveau_statut);
      
      switch (req.user.role) {
        case 'admin': {
          // L'admin peut faire presque toutes les transitions
          const adminTransitions = {
            '√Ä revoir': ['En cours', 'En impression', 'Pr√™t impression', 'Imprim√©', 'Termin√©'],
            'En cours': ['√Ä revoir', 'Pr√™t impression', 'En impression', 'Imprim√©', 'Termin√©'],
            'Pr√™t impression': ['En impression', '√Ä revoir', 'En cours', 'Imprim√©', 'Termin√©'],
            'En impression': ['Imprim√©', '√Ä revoir', 'En cours', 'Pr√™t impression', 'Termin√©'],
            'Imprim√©': ['Pr√™t livraison', 'En impression', '√Ä revoir', 'En cours', 'Termin√©'],
            'Pr√™t livraison': ['En livraison', 'Imprim√©', 'En impression', 'Termin√©'],
            'En livraison': ['Livr√©', 'Pr√™t livraison', 'Imprim√©', 'Termin√©'],
            'Livr√©': ['Termin√©', 'Pr√™t livraison', 'En livraison', 'En cours', 'Imprim√©'],
            'Termin√©': ['Livr√©', 'En cours', '√Ä revoir', 'En impression'], // Permettre de revenir depuis Termin√©, y compris remettre en impression
          };
          return (adminTransitions[current] || []).includes(target);
        }
        case 'preparateur': {
          // Le pr√©parateur peut g√©rer ses dossiers et faire les transitions de pr√©paration
          const prepTransitions = {
            '√Ä revoir': ['En cours', 'Pr√™t impression'],
            'En cours': ['√Ä revoir', 'Pr√™t impression'],
            'Pr√™t impression': ['En cours', '√Ä revoir', 'En impression'],
          };
          return (prepTransitions[current] || []).includes(target);
        }
        case 'imprimeur_roland':
        case 'imprimeur_xerox': {
          const printTransitions = {
            'En cours': ['√Ä revoir', 'Pr√™t impression', 'En impression'],
            'Pr√™t impression': ['En impression', '√Ä revoir', 'En cours'],
            'En impression': ['Imprim√©', '√Ä revoir', 'Pr√™t livraison', 'En cours'],
            'Imprim√©': ['Pr√™t livraison', '√Ä revoir', 'En impression', 'Termin√©'],
            'Pr√™t livraison': ['En livraison', 'Imprim√©', 'En impression'],
          };
          return (printTransitions[current] || []).includes(target);
        }
        case 'livreur': {
          const deliveryTransitions = {
            'Imprim√©': ['Pr√™t livraison'],
            'Pr√™t livraison': ['En livraison', 'Imprim√©'],
            'En livraison': ['Termin√©', 'Livr√©', 'Pr√™t livraison'],
            'Livr√©': ['Termin√©'],
          };
          return (deliveryTransitions[current] || []).includes(target);
        }
        default:
          return false;
      }
    };

    if (!canChangeStatus()) {
      return res.status(403).json({
        success: false,
        message: `Changement de statut non autoris√©. Statut actuel: ${dossier.statut}, Votre r√¥le: ${req.user.role}`,
      });
    }

    // Mise √† jour avec les champs optionnels
    let updateFields = ['statut = $1', 'updated_at = CURRENT_TIMESTAMP'];
    let values = [nouveau_statut];
    let paramIndex = 2;

    if (date_livraison_prevue !== undefined) {
      updateFields.push(`date_livraison_prevue = $${paramIndex}`);
      values.push(date_livraison_prevue);
      paramIndex++;
    }
    if (date_livraison !== undefined) {
      updateFields.push(`date_livraison_reelle = $${paramIndex}`);
      values.push(date_livraison);
      paramIndex++;
    }
    if (mode_paiement !== undefined) {
      updateFields.push(`mode_paiement = $${paramIndex}`);
      values.push(mode_paiement);
      paramIndex++;
    }
    if (montant_cfa !== undefined) {
      updateFields.push(`montant_cfa = $${paramIndex}`);
      values.push(montant_cfa);
      paramIndex++;
    }

    const updateQuery = `
      UPDATE dossiers 
      SET ${updateFields.join(', ')}
      WHERE id = $${paramIndex}
      RETURNING *
    `;

    values.push(dossier.id); // Utiliser l'ID r√©el du dossier
    const result = await db.query(updateQuery, values);
    const updatedDossier = result.rows[0];

    // Ajouter commentaire si fourni
    if (commentaire) {
      await db.query(
        `
        UPDATE dossier_status_history 
        SET commentaire = $1 
        WHERE id = (
          SELECT id FROM dossier_status_history 
          WHERE dossier_id = $2 AND nouveau_statut = $3 AND commentaire IS NULL
          ORDER BY changed_at DESC LIMIT 1
        )
      `,
        [commentaire, dossier.id, nouveau_statut]
      );
    }

    // √âmission Socket.IO via service centralis√©
    socketService.emitStatusChanged(
      updatedDossier.folder_id, 
      dossier.statut, 
      nouveau_statut, 
      updatedDossier
    );
    
    // Logger l'activit√©
    await logDossierActivity(updatedDossier.folder_id, req.user.id, 'status_changed', {
      old_status: dossier.statut,
      new_status: nouveau_statut,
      commentaire,
    });

    return res.json({
      success: true,
      message: `Statut chang√©: ${dossier.statut} ‚Üí ${nouveau_statut}`,
      dossier: {
        ...updatedDossier,
        id: updatedDossier.folder_id,
        legacy_id: updatedDossier.id,
      },
    });
  } catch (error) {
    console.error('Erreur changement de statut (fixed):', error);
    return res.status(500).json({
      success: false,
      message: 'Erreur lors du changement de statut',
      error: error.message,
    });
  }
}

// üîÑ PUT /dossiers/:id/statut - Changer le statut d'un dossier
router.put('/:id/statut', auth, checkDossierPermission('change_status'), async (req, res) => {
  return changeStatutCoreFixed(req, res);
});

// üîÅ ALIAS PATCH /dossiers/:id/status - Payload { status, comment } (compat guide)
router.patch('/:id/status', auth, checkDossierPermission('change_status'), async (req, res) => {
  try {
    const mapAppToFr = {
      en_cours: 'En cours',
      a_revoir: '√Ä revoir',
      en_impression: 'En impression',
      termine: 'Termin√©',
      imprime: 'Imprim√©',
      pret_impression: 'Pr√™t impression',
      pret_livraison: 'Pr√™t livraison',
      en_livraison: 'En livraison',
      livre: 'Livr√©',
    };
    const status = req.body?.status;
    const comment = req.body?.comment ?? req.body?.commentaire ?? null;
    if (!status) {
      return res.status(400).json({ success: false, message: 'Champ status requis' });
    }
    req.body.nouveau_statut = mapAppToFr[status] || status;
    req.body.commentaire = comment;
    return changeStatutCoreFixed(req, res);
  } catch (e) {
    console.error('Erreur alias PATCH /status:', e);
    return res
      .status(500)
      .json({ success: false, message: 'Erreur alias status', error: e.message });
  }
});

// ‚úÖ PUT /dossiers/:id/valider - Valider un dossier (Pr√©parateur)
router.put('/:id/valider', auth, checkRole(['preparateur']), validateIdParam('id'), async (req, res) => {
  try {
    const { id: idParam } = req.params;
    const { commentaire = null } = req.body || {};

    // Log debug pour aider √† diagnostiquer les probl√®mes de validation
    console.log('[VALIDATE_DOSSIER] user:', { id: req.user?.id, role: req.user?.role }, 'param:', idParam);

    // 1. Charger le dossier par identifiant (supporte UUID folder_id et ID num√©rique)
    const d = await getDossierByIdentifier(idParam);
    if (!d) {
      console.warn('[VALIDATE_DOSSIER] Dossier introuvable pour', idParam);
      return res.status(404).json({ success: false, message: 'Ce dossier n\'existe pas' });
    }
    console.log('[VALIDATE_DOSSIER] Dossier r√©solu:', { realId: d.id, folder_id: d.folder_id, created_by: d.created_by, preparateur_id: d.preparateur_id, statut: d.statut });

    // 2. V√©rifier les permissions avec la nouvelle logique
    const permissionResult = canAccessDossier(req.user, d, 'validate');
    if (!permissionResult.allowed) {
      console.warn('[VALIDATE_DOSSIER] Permission refus√©e:', permissionResult.message);
      return res.status(403).json({ 
        success: false, 
        message: permissionResult.message || "Vous n'√™tes pas autoris√© √† valider ce dossier" 
      });
    }

    // 3. Emp√™cher double validation
    if (d["valid√©_preparateur"] === true || d.valide_preparateur === true) {
      return res.status(400).json({ success: false, message: 'Dossier d√©j√† valid√©' });
    }

    // 4. V√©rifier pr√©sence fichier(s) (utiliser l'ID r√©el du dossier)
    const filesCheck = await db.query('SELECT COUNT(*) FROM fichiers WHERE dossier_id = $1', [d.id]);
    if (parseInt(filesCheck.rows[0].count) === 0) {
      console.warn('[VALIDATE_DOSSIER] Aucun fichier pour dossier', d.id);
      return res.status(400).json({ success: false, message: 'Impossible de valider un dossier sans fichiers' });
    }

    // 5. Normaliser le statut interne: on persiste un code interne stable
    // On utilise 'En impression' pour la DB (format attendu dans le CHECK constraint)
    // et 'en_impression' comme code normalis√© pour le frontend
    const statutPersist = 'En impression';  // Format attendu en DB - pour la base de donn√©es
    const statutLabelFr = 'En impression';  // Pour l'historique et les logs
    const statutCodeNormalise = 'en_impression';  // Code normalis√© pour le frontend

    // 6. Mettre √† jour le dossier: statut code + flag valid√©_preparateur + date_validation_preparateur
    const updateQuery = `
      UPDATE dossiers
      SET statut = $2, "valid√©_preparateur" = true, date_validation_preparateur = NOW(),
          commentaire_revision = COALESCE($3, commentaire_revision)
      WHERE id = $1
      RETURNING *
    `;
    const updateResult = await db.query(updateQuery, [d.id, statutPersist, commentaire]);
    const dossier = updateResult.rows[0];

    // 6. Ins√©rer dans l'historique si table pr√©sente (ignore erreurs silencieusement)
    try {
      await db.query(
        `INSERT INTO dossier_status_history (dossier_id, ancien_statut, nouveau_statut, changed_by, commentaire)
         VALUES ($1, $2, $3, $4, $5)` ,
        [id, d.statut, statutLabelFr, req.user.id, commentaire]
      );
    } catch (e) {
      console.warn('‚ö†Ô∏è Historique non enregistr√©:', e.message);
    }

    // 7. Notifications temps r√©el
    const io = req.app.get('io');
    if (io) {
      io.emit('dossier_validated', {
        dossier,
        validated_by: req.user.nom,
        message: `Dossier ${dossier.numero_commande || dossier.numero || dossier.id} valid√© (pr√™t impression)`
      });
      io.emit('dossier_status_changed', {
        dossier,
        ancien_statut: d.statut,
        nouveau_statut: statutLabelFr,
        changed_by: req.user.nom,
        commentaire: commentaire || null,
        message: `Statut du dossier ${dossier.numero_commande || dossier.numero || dossier.id} chang√©: ${d.statut} ‚Üí ${statutLabelFr}`
      });
    }

    // 8. R√©ponse enrichie avec alias legacy + code normalis√©
    return res.json({
      success: true,
      message: 'Dossier valid√© avec succ√®s. Il est maintenant visible par les imprimeurs.',
      dossier: {
        ...dossier,
        statut: statutCodeNormalise,  // Envoyer le code normalis√© au frontend
        statut_legacy: statutLabelFr,
        statut_normalise: statutCodeNormalise,
        valid√©_preparateur: true,  // S'assurer que le flag est bien retourn√©
      }
    });
  } catch (error) {
    console.error('Erreur PUT /dossiers/:id/valider:', error);
    return res.status(500).json({
      success: false,
      message: 'Erreur lors de la validation du dossier',
      error: error.message,
    });
  }
});

// ‚úÖ PUT /dossiers/:id/remettre-en-impression - Remettre un dossier en impression (Admin)
router.put('/:id/remettre-en-impression', auth, checkRole(['admin']), validateIdParam('id'), async (req, res) => {
  try {
    const { id } = req.params;
    const { commentaire = null } = req.body || {};

    // 1. Charger le dossier
    const checkResult = await db.query(
      `SELECT id, created_by, preparateur_id, statut FROM dossiers WHERE id = $1`,
      [id]
    );
    if (checkResult.rows.length === 0) {
      return res.status(404).json({ success: false, message: 'Ce dossier n\'existe pas ou vous n\'avez pas l\'autorisation de le remettre en impression' });
    }
    const d = checkResult.rows[0];
    const userId = parseInt(req.user.id);

    // 2. V√©rifier que le dossier est dans un √©tat "termin√©" ou "imprim√©"
    const statutsAutorises = ['Termin√©', 'Imprim√©', 'Livr√©'];
    if (!statutsAutorises.includes(d.statut)) {
      return res.status(400).json({ 
        success: false, 
        message: `Impossible de remettre en impression depuis l'√©tat "${d.statut}". √âtats autoris√©s: ${statutsAutorises.join(', ')}` 
      });
    }

    // 3. D√©finir le nouveau statut
    const statutPersist = 'En impression';  // Format attendu en DB
    const statutLabelFr = 'En impression';  // Pour l'historique et les logs
    const statutCodeNormalise = 'en_impression';  // Code normalis√© pour le frontend

    // 4. Mettre √† jour le dossier
    const updateQuery = `
      UPDATE dossiers
      SET statut = $2, updated_at = NOW(),
          commentaire_revision = COALESCE($3, commentaire_revision)
      WHERE id = $1
      RETURNING *
    `;
    const updateResult = await db.query(updateQuery, [id, statutPersist, commentaire]);
    const dossier = updateResult.rows[0];

    // 5. Ins√©rer dans l'historique
    try {
      await db.query(
        `INSERT INTO dossier_status_history (dossier_id, ancien_statut, nouveau_statut, changed_by, commentaire)
         VALUES ($1, $2, $3, $4, $5)`,
        [id, d.statut, statutLabelFr, userId, commentaire || 'Remise en impression par admin']
      );
    } catch (e) {
      console.warn('‚ö†Ô∏è Historique non enregistr√©:', e.message);
    }

    // 6. Notifications temps r√©el
    const io = req.app.get('io');
    if (io) {
      io.emit('dossier_status_changed', {
        dossier,
        ancien_statut: d.statut,
        nouveau_statut: statutLabelFr,
        changed_by: req.user.nom,
        commentaire: commentaire || 'Remise en impression par admin',
        message: `Dossier ${dossier.numero_commande || dossier.numero || dossier.id} remis en impression par ${req.user.nom}`
      });
    }

    // 7. Log pour audit
    console.log(`‚úÖ ADMIN REPRINT: Dossier ${id} remis en impression: ${d.statut} ‚Üí ${statutLabelFr} par ${req.user.nom}`);

    // 8. R√©ponse
    res.json({
      success: true,
      message: `Dossier remis en impression avec succ√®s: ${d.statut} ‚Üí ${statutLabelFr}`,
      dossier,
      statut_code: statutCodeNormalise,
      ancien_statut: d.statut,
      nouveau_statut: statutLabelFr,
      commentaire: commentaire || 'Remise en impression par admin'
    });

  } catch (error) {
    console.error('Erreur PUT /dossiers/:id/remettre-en-impression:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la remise en impression du dossier',
      error: error.message,
    });
  }
});

// üì§ POST /dossiers/:id/fichiers - Upload de fichiers (supporte folder_id UUID)
router.post('/:id/fichiers', auth, checkDossierPermission('upload_file'), upload.array('files', 10), async (req, res) => {
  try {
    const { id: dossierId } = req.params;
    
    // Le dossier a d√©j√† √©t√© charg√© et v√©rifi√© par checkDossierPermission
    const dossier = req.dossier;

    // V√©rifications suppl√©mentaires du workflow de validation des fichiers
    if (req.user.role === 'preparateur') {
      // Pr√©parateur: v√©rifier propri√©t√© + workflow de validation
      const isOwner = dossier.created_by === req.user.id || dossier.preparateur_id === req.user.id;
      if (!isOwner) {
        return res.status(403).json({
          success: false,
          message: 'Seul le cr√©ateur du dossier peut ajouter des fichiers',
        });
      }

      // Workflow de validation: upload interdit si dossier valid√© SAUF si statut "√Ä revoir"
      const allowedStatuses = ['En cours', 'en_cours', '√Ä revoir', 'a_revoir'];
      if (dossier.valide_preparateur && !['√Ä revoir', 'a_revoir'].includes(dossier.statut)) {
        return res.status(403).json({
          success: false,
          message: 'Upload interdit: dossier valid√© et fig√©. Disponible uniquement si remis "√Ä revoir"',
        });
      }
      
      if (!allowedStatuses.includes(dossier.statut)) {
        return res.status(403).json({
          success: false,
          message: `Upload non autoris√© pour le statut "${dossier.statut}"`,
        });
      }
    }

    if (!req.files || req.files.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Aucun fichier fourni',
      });
    }

    const uploadedFiles = [];

    for (const file of req.files) {
      try {
        const fileExtension = path.extname(file.originalname).toLowerCase();
        const relativePath = `uploads/${dossier.folder_id || dossierId}/${file.filename}`;

        const fileBuffer = await fs.readFile(file.path);
        const crypto = require('crypto');
        const checksum = crypto.createHash('sha256').update(fileBuffer).digest('hex');

        const existingFileCheck = await db.query(
          'SELECT id FROM fichiers WHERE dossier_id = $1 AND checksum = $2',
          [dossier.id, checksum]
        );

        if (existingFileCheck.rows.length > 0) {
          await fs.unlink(file.path);
          continue;
        }

        const insertQuery = `
          INSERT INTO fichiers (
            dossier_id, nom, chemin, type, taille, uploaded_by, 
            mime_type, extension, checksum
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
          RETURNING *
        `;

        const values = [
          dossier.id,
          file.originalname,
          relativePath,
          file.mimetype.startsWith('image/') ? 'image' : 'document',
          file.size,
          parseInt(req.user.id),
          file.mimetype,
          fileExtension,
          checksum,
        ];

        const result = await db.query(insertQuery, values);
        uploadedFiles.push(result.rows[0]);
      } catch (fileError) {
        console.error(`Erreur traitement fichier ${file.originalname}:`, fileError);
      }
    }

    if (uploadedFiles.length === 0) {
      return res.status(400).json({
        success: false,
        message: "Aucun fichier n'a pu √™tre upload√© (doublons ou erreurs)",
      });
    }

    // √âmission Socket.IO pour chaque fichier
    for (const file of uploadedFiles) {
      socketService.emitFileUploaded(dossier.folder_id, file);
      await logDossierActivity(dossier.folder_id, req.user.id, 'file_uploaded', {
        file_name: file.nom,
        file_size: file.taille,
      });
    }

    res.json({
      success: true,
      message: `${uploadedFiles.length} fichier(s) upload√©(s) avec succ√®s`,
      files: uploadedFiles,
    });
  } catch (error) {
    console.error('Erreur POST /dossiers/:id/fichiers:', error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de l'upload des fichiers",
      error: error.message,
    });
  }
});

// üì• GET /dossiers/:id/fichiers - Liste des fichiers d'un dossier
router.get('/:id/fichiers', auth, checkDossierPermission('view'), async (req, res) => {
  try {
    // Le dossier a d√©j√† √©t√© charg√© et v√©rifi√© par checkDossierPermission
    const dossier = req.dossier;

    const filesQuery = `
      SELECT f.*, u.nom as uploaded_by_name 
      FROM fichiers f
      LEFT JOIN users u ON f.uploaded_by = u.id
      WHERE f.dossier_id = $1
      ORDER BY f.uploaded_at DESC
    `;

    const filesResult = await db.query(filesQuery, [dossier.id]);

    res.json({
      success: true,
      files: filesResult.rows,
    });
  } catch (error) {
    console.error('Erreur GET /dossiers/:id/fichiers:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la r√©cup√©ration des fichiers',
      error: error.message,
    });
  }
});

// ÔøΩÔ∏è GET /fichiers/:id/preview - Pr√©visualiser un fichier (streaming)
router.get('/fichiers/:id/preview', auth, async (req, res) => {
  try {
    const { id: fileId } = req.params;

    const fileQuery = `
      SELECT f.*, d.folder_id FROM fichiers f
      JOIN dossiers d ON f.dossier_id = d.id
      WHERE f.id = $1
    `;

    const fileResult = await db.query(fileQuery, [fileId]);

    if (fileResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Fichier non trouv√©',
      });
    }

    const file = fileResult.rows[0];

    // V√©rifier permissions via getDossierByIdentifier
    const dossier = await getDossierByIdentifier(file.folder_id);
    if (!dossier) {
      return res.status(404).json({
        success: false,
        message: 'Dossier associ√© non trouv√©',
      });
    }

    const access = checkUserAccess(dossier, req.user);
    if (!access.allowed) {
      return res.status(403).json({
        success: false,
        message: access.reason,
      });
    }

    const fullPath = path.join(__dirname, '../..', file.chemin);

    try {
      await fs.access(fullPath);
    } catch {
      return res.status(404).json({
        success: false,
        message: 'Fichier physique non trouv√©',
      });
    }

    // Headers pour pr√©visualisation inline
    res.setHeader('Content-Type', file.mime_type || 'application/octet-stream');
    res.setHeader('Content-Disposition', `inline; filename="${file.nom}"`);
    res.setHeader('Cache-Control', 'public, max-age=86400'); // Cache 24h

    res.sendFile(fullPath);
  } catch (error) {
    console.error('Erreur GET /fichiers/:id/preview:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la pr√©visualisation',
      error: error.message,
    });
  }
});

// ÔøΩüìÇ GET /fichiers/:id/download - T√©l√©charger un fichier
router.get('/fichiers/:id/download', auth, async (req, res) => {
  try {
    const { id: fileId } = req.params;

    const fileQuery = `
      SELECT f.*, d.* FROM fichiers f
      JOIN dossiers d ON f.dossier_id = d.id
      WHERE f.id = $1
    `;

    const fileResult = await db.query(fileQuery, [fileId]);

    if (fileResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Fichier non trouv√©',
      });
    }

    const file = fileResult.rows[0];

    // V√©rifier permissions via getDossierByIdentifier
    const dossier = await getDossierByIdentifier(file.folder_id || file.dossier_id);
    if (!dossier) {
      return res.status(404).json({
        success: false,
        message: 'Dossier associ√© non trouv√©',
      });
    }

    const access = checkUserAccess(dossier, req.user);
    if (!access.allowed) {
      return res.status(403).json({
        success: false,
        message: access.reason,
      });
    }

    const fullPath = path.join(__dirname, '../..', file.chemin);

    try {
      await fs.access(fullPath);
    } catch (accessError) {
      return res.status(404).json({
        success: false,
        message: 'Fichier physique non trouv√© sur le serveur',
      });
    }

    res.setHeader('Content-Disposition', `attachment; filename="${file.nom}"`);
    res.setHeader('Content-Type', file.mime_type || 'application/octet-stream');

    res.sendFile(fullPath);
  } catch (error) {
    console.error('Erreur GET /fichiers/:id/download:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors du t√©l√©chargement du fichier',
      error: error.message,
    });
  }
});

// üóëÔ∏è DELETE /fichiers/:id - Supprimer un fichier
router.delete('/fichiers/:id', auth, async (req, res) => {
  try {
    const { id: fileId } = req.params;

    const fileQuery = `
      SELECT f.*, d.created_by, d.valide_preparateur, d.numero_commande
      FROM fichiers f
      JOIN dossiers d ON f.dossier_id = d.id
      WHERE f.id = $1
    `;

    const fileResult = await db.query(fileQuery, [fileId]);

    if (fileResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Fichier non trouv√©',
      });
    }

    const file = fileResult.rows[0];

    const canDelete =
      req.user.role === 'admin' ||
      (req.user.role === 'preparateur' &&
        file.created_by === parseInt(parseInt(req.user.id)) &&
        !file.valide_preparateur);

    if (!canDelete) {
      return res.status(403).json({
        success: false,
        message:
          "Suppression non autoris√©e. Le dossier est valid√© ou vous n'en √™tes pas le cr√©ateur.",
      });
    }

    await db.query('DELETE FROM fichiers WHERE id = $1', [fileId]);

    const fullPath = path.join(__dirname, '../..', file.chemin);
    try {
      await fs.unlink(fullPath);
    } catch (unlinkError) {
      console.warn('Impossible de supprimer le fichier physique:', unlinkError);
    }

    // R√©cup√©rer le dossier pour avoir le folder_id
    const dossierResult = await db.query('SELECT folder_id FROM dossiers WHERE id = $1', [file.dossier_id]);
    const folderId = dossierResult.rows[0]?.folder_id;
    
    if (folderId) {
      socketService.emitFileDeleted(folderId, fileId, file.nom);
      await logDossierActivity(folderId, req.user.id, 'file_deleted', {
        file_name: file.nom,
      });
    }

    res.json({
      success: true,
      message: `Fichier ${file.nom} supprim√© avec succ√®s`,
    });
  } catch (error) {
    console.error('Erreur DELETE /fichiers/:id:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la suppression du fichier',
      error: error.message,
    });
  }
});

// üóëÔ∏è DELETE /dossiers/:id - Supprimer un dossier et tous ses fichiers (supporte folder_id UUID)
router.delete('/:id', auth, checkDossierPermission('delete'), async (req, res) => {
  try {
    const { id: dossierId } = req.params;
    const user = req.user;

    // Charger le dossier
    const dossierResult = await db.query('SELECT * FROM dossiers d WHERE d.id = $1', [dossierId]);
    if (dossierResult.rows.length === 0) {
      return res.status(404).json({ success: false, message: 'Ce dossier n\'existe pas ou vous n\'avez pas l\'autorisation de le supprimer' });
    }
    const dossier = dossierResult.rows[0];

    // Autorisation: admin OU pr√©parateur propri√©taire du dossier (statuts En cours/√Ä revoir)
    const isAdmin = user.role === 'admin';
    const isPreparateurOwner =
      user.role === 'preparateur' &&
      dossier.created_by === parseInt(user.id) &&
      (dossier.statut === 'En cours' || dossier.statut === '√Ä revoir');
    if (!isAdmin && !isPreparateurOwner) {
      return res.status(403).json({ success: false, message: 'Suppression non autoris√©e' });
    }

    // Supprimer les fichiers physiques et en base
    const filesResult = await db.query('SELECT * FROM fichiers WHERE dossier_id = $1', [dossierId]);
    for (const file of filesResult.rows) {
      const fullPath = path.join(__dirname, '../..', file.chemin);
      try {
        await fs.unlink(fullPath);
      } catch (unlinkError) {
        console.warn(`Impossible de supprimer le fichier physique ${file.nom}:`, unlinkError);
      }
    }
    await db.query('DELETE FROM fichiers WHERE dossier_id = $1', [dossierId]);

    // Supprimer le r√©pertoire uploads du dossier
    const uploadPath = path.join(__dirname, '../../uploads', dossierId);
    try {
      // rm r√©cursif remplace rmdir d√©pr√©ci√©
      await fs.rm(uploadPath, { recursive: true, force: true });
    } catch (rmdirError) {
      console.warn('Impossible de supprimer le r√©pertoire du dossier:', rmdirError);
    }

    // Supprimer l'historique √©ventuel (optionnel)
    try {
      await db.query('DELETE FROM dossier_status_history WHERE dossier_id = $1', [dossierId]);
    } catch (_) {}

    // Supprimer le dossier
    await db.query('DELETE FROM dossiers WHERE id = $1', [dossierId]);

    // Notifier via Socket.IO
    socketService.emitDossierDeleted(dossier.folder_id, {
      numero_commande: dossier.numero_commande,
      deleted_by: user.nom,
    });
    
    // Logger (avant suppression pour avoir le folder_id)
    await logDossierActivity(dossier.folder_id, user.id, 'deleted', {
      numero_commande: dossier.numero_commande,
    });

    res.json({ success: true, message: `Dossier ${dossier.numero_commande} supprim√© avec succ√®s` });
  } catch (error) {
    console.error('Erreur DELETE /dossiers/:id:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la suppression du dossier',
      error: error.message,
    });
  }
});

// Export du routeur pour utilisation par server.js
module.exports = router;
